# Story 27.4: TTS Provider Abstraction Layer

**Status:** Ready for Review

**Epic:** Epic 27 - DreamAI - AI-Powered Content Generation
**Story Points:** 5
**Priority:** High
**Dependencies:** None (foundation story for TTS infrastructure)

---

## Story

**As a** system,
**I want** an abstracted TTS service layer that supports multiple providers with automatic fallback,
**so that** audio generation for vocabulary and learning materials can reliably switch between providers when one fails.

---

## Acceptance Criteria

1. [ ] Abstract base class/interface for TTS providers
2. [ ] Language detection and voice selection
3. [ ] Audio format configuration (MP3, WAV)
4. [ ] Caching layer for generated audio
5. [ ] Provider fallback support
6. [ ] Batch generation support

---

## Tasks / Subtasks

- [x] **Task 1: Create TTS Exception Hierarchy** (AC: 1, 5)
  - [x] Create `backend/app/services/tts/exceptions.py`
  - [x] Implement `TTSProviderError` base exception
  - [x] Implement `TTSConnectionError` for network failures
  - [x] Implement `TTSAuthenticationError` for API key issues
  - [x] Implement `TTSRateLimitError` with retry_after_seconds
  - [x] Implement `TTSTimeoutError` for request timeouts
  - [x] Implement `TTSAudioGenerationError` for audio generation failures
  - [x] Implement `TTSUnsupportedLanguageError` for unsupported languages
  - [x] Implement `AllTTSProvidersFailedError` for fallback exhaustion

- [x] **Task 2: Create TTS Base Types and Models** (AC: 1, 2, 3)
  - [x] Create `backend/app/services/tts/base.py`
  - [x] Create `TTSProviderType` enum (EDGE, AZURE, GOOGLE)
  - [x] Create `AudioFormat` enum (MP3, WAV, OGG)
  - [x] Create `Voice` Pydantic model (id, name, language, gender, style)
  - [x] Create `AudioGenerationOptions` Pydantic model:
    - language: str
    - voice: str | None (auto-select if None)
    - format: AudioFormat = MP3
    - rate: float = 1.0 (speech rate)
    - pitch: float = 1.0 (pitch adjustment)
  - [x] Create `AudioResult` Pydantic model:
    - audio_data: bytes
    - format: AudioFormat
    - duration_ms: int
    - voice_used: str
    - provider: str
    - latency_ms: int
    - cached: bool = False
  - [x] Create `BatchAudioResult` model for batch operations

- [x] **Task 3: Create TTSProvider Abstract Base Class** (AC: 1)
  - [x] Define abstract `generate_audio(text, options) -> AudioResult` method
  - [x] Define abstract `generate_audio_batch(items, options) -> list[AudioResult]` method (AC: 6)
  - [x] Define abstract `get_name() -> str` method
  - [x] Define abstract `get_available_voices(language) -> list[Voice]` method (AC: 2)
  - [x] Define abstract `get_supported_languages() -> list[str]` method
  - [x] Define abstract `is_available() -> bool` method
  - [x] Define abstract `supports_language(language) -> bool` method
  - [x] Add docstrings using Google style

- [x] **Task 4: Create TTS Configuration** (AC: 1)
  - [x] Create `backend/app/services/tts/config.py`
  - [x] Create `TTSSettings` Pydantic Settings model:
    - TTS_ENABLED: bool = True
    - TTS_PRIMARY_PROVIDER: str = "edge"
    - TTS_FALLBACK_PROVIDER: str | None = "azure"
    - TTS_DEFAULT_LANGUAGE: str = "en"
    - TTS_DEFAULT_FORMAT: str = "mp3"
    - TTS_CACHE_ENABLED: bool = True
    - TTS_CACHE_TTL_HOURS: int = 24
    - TTS_REQUEST_TIMEOUT: int = 30
    - TTS_MAX_RETRIES: int = 3
    - AZURE_TTS_KEY: str | None = None
    - AZURE_TTS_REGION: str = "turkeycentral"
  - [x] Implement `get_tts_settings()` function
  - [x] Implement `get_primary_provider_type()` method
  - [x] Implement `get_fallback_provider_type()` method

- [x] **Task 5: Create Audio Cache Service** (AC: 4)
  - [x] Create `backend/app/services/tts/cache.py`
  - [x] Create `AudioCacheKey` model (text_hash, language, voice, format)
  - [x] Create `AudioCache` class with:
    - `get(key) -> bytes | None` method
    - `set(key, audio_data, ttl) -> None` method
    - `delete(key) -> None` method
    - `clear() -> None` method
    - `get_cache_key(text, language, voice, format) -> AudioCacheKey` method
  - [x] Implement in-memory cache with TTL support (dict + timestamps)
  - [x] Add cache hit/miss logging
  - [x] Note: Redis caching can be added in Phase 2

- [x] **Task 6: Create TTS Manager with Fallback** (AC: 5, 6)
  - [x] Create `backend/app/services/tts/manager.py`
  - [x] Create `TTSManager` class with:
    - `__init__(settings, providers, cache)` constructor
    - `register_provider(provider_type, provider)` method
    - `get_provider(provider_type) -> TTSProvider | None` method
    - `get_available_providers() -> list[TTSProvider]` method
    - `generate_audio(text, options) -> AudioResult` with fallback
    - `generate_audio_batch(items, options) -> list[AudioResult]` with fallback (AC: 6)
    - `is_available() -> bool` method
  - [x] Implement provider fallback logic (try primary, then fallback)
  - [x] Integrate cache layer (check cache before generation, store after)
  - [x] Add detailed logging for provider selection and fallback
  - [x] Implement `get_tts_manager()` global accessor
  - [x] Implement `reset_tts_manager()` for testing
  - [x] Implement `create_default_manager()` factory function

- [x] **Task 7: Create Module Exports** (AC: 1)
  - [x] Create `backend/app/services/tts/__init__.py`
  - [x] Export all public types: TTSProvider, TTSProviderType, AudioFormat, Voice, AudioGenerationOptions, AudioResult
  - [x] Export TTSManager, get_tts_manager, create_default_manager
  - [x] Export all exception types
  - [x] Create `backend/app/services/tts/providers/__init__.py` (empty for now)

- [x] **Task 8: Write Unit Tests** (AC: All)
  - [x] Create `backend/app/tests/test_services/test_tts/` directory
  - [x] Create `backend/app/tests/test_services/test_tts/__init__.py`
  - [x] Create `backend/app/tests/test_services/test_tts/test_base.py`:
    - Test TTSProviderType enum values
    - Test AudioFormat enum values
    - Test Voice model validation
    - Test AudioGenerationOptions defaults and validation
    - Test AudioResult model
  - [x] Create `backend/app/tests/test_services/test_tts/test_exceptions.py`:
    - Test exception hierarchy
    - Test exception string formatting
    - Test AllTTSProvidersFailedError with provider errors list
  - [x] Create `backend/app/tests/test_services/test_tts/test_config.py`:
    - Test TTSSettings defaults
    - Test environment variable loading
    - Test get_primary_provider_type()
    - Test get_fallback_provider_type()
  - [x] Create `backend/app/tests/test_services/test_tts/test_cache.py`:
    - Test cache key generation
    - Test cache get/set/delete operations
    - Test cache TTL expiration
    - Test cache hit/miss scenarios
  - [x] Create `backend/app/tests/test_services/test_tts/test_manager.py`:
    - Test manager initialization
    - Test provider registration
    - Test get_available_providers
    - Test generate_audio with mock provider
    - Test fallback when primary fails
    - Test cache integration
    - Test AllTTSProvidersFailedError when all fail
    - Test generate_audio_batch with mock provider

---

## Dev Notes

### Previous Story Insights (from 27.1-27.3)
[Source: docs/stories/27.1.llm-provider-abstraction-layer.md, 27.3.gemini-provider-integration.md]

The LLM provider abstraction established these patterns that TTS should follow:
- Abstract base class with clear abstract methods
- Pydantic models for all options and results
- Exception hierarchy with specific error types
- Manager class with fallback logic
- Settings via Pydantic BaseSettings
- Global manager accessor with lazy initialization
- Factory function for creating pre-configured manager

Key files to reference:
- `backend/app/services/llm/base.py` - Abstract provider pattern
- `backend/app/services/llm/manager.py` - Fallback orchestration pattern
- `backend/app/services/llm/exceptions.py` - Exception hierarchy pattern
- `backend/app/services/llm/config.py` - Settings pattern

### Source Tree Reference
[Source: architecture/source-tree.md]

New files to create:
```
backend/app/services/tts/
├── __init__.py           # Module exports
├── base.py               # TTSProvider ABC, models, enums
├── config.py             # TTSSettings
├── cache.py              # AudioCache service
├── exceptions.py         # TTS exception hierarchy
├── manager.py            # TTSManager with fallback
└── providers/
    └── __init__.py       # Provider exports (empty for now)

backend/app/tests/test_services/test_tts/
├── __init__.py
├── test_base.py
├── test_cache.py
├── test_config.py
├── test_exceptions.py
└── test_manager.py
```

### TTS Provider Interface Specification
[Source: docs/prd/epic-27-dreamai-content-generation.md]

```python
class TTSProvider(ABC):
    @abstractmethod
    async def generate_audio(self, text: str, options: AudioGenerationOptions) -> AudioResult:
        """Generate audio from text."""
        pass

    @abstractmethod
    async def generate_audio_batch(
        self, items: list[tuple[str, AudioGenerationOptions]],
    ) -> list[AudioResult]:
        """Generate audio for multiple texts."""
        pass

    @abstractmethod
    def get_available_voices(self, language: str) -> list[Voice]:
        """Get available voices for a language."""
        pass

    @abstractmethod
    def get_supported_languages(self) -> list[str]:
        """Get list of supported language codes."""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Return provider name."""
        pass

    @abstractmethod
    def is_available(self) -> bool:
        """Check if provider is configured and available."""
        pass

    @abstractmethod
    def supports_language(self, language: str) -> bool:
        """Check if language is supported."""
        pass
```

### Voice Model Specification
[Source: docs/prd/epic-27-dreamai-content-generation.md]

```python
class Voice(BaseModel):
    id: str                    # Provider-specific voice ID
    name: str                  # Human-readable name
    language: str              # BCP-47 language code (e.g., "en-US", "tr-TR")
    gender: str                # "male", "female", "neutral"
    style: str | None = None   # Voice style (e.g., "neural", "standard")
```

### Audio Format Support
[Source: docs/prd/epic-27-dreamai-content-generation.md]

- **MP3**: Default format, best compression, widely compatible
- **WAV**: Uncompressed, highest quality, larger files
- **OGG**: Open format, good compression (future support)

### Caching Strategy
[Source: docs/prd/epic-27-dreamai-content-generation.md]

Audio caching is critical for vocabulary because:
- Same word is requested many times across students
- Reduces TTS API calls and costs
- Improves response time for repeated content

Cache key components:
- Text hash (MD5 or SHA256 of normalized text)
- Language code
- Voice ID
- Audio format

Initial implementation uses in-memory dict with TTL. Redis can be added in Phase 2 for persistence across restarts.

### Environment Variables
[Source: docs/prd/epic-27-dreamai-content-generation.md]

```bash
# TTS Configuration
TTS_ENABLED=true
TTS_PRIMARY_PROVIDER=edge        # edge, azure, google
TTS_FALLBACK_PROVIDER=azure
TTS_DEFAULT_LANGUAGE=en
TTS_DEFAULT_FORMAT=mp3
TTS_CACHE_ENABLED=true
TTS_CACHE_TTL_HOURS=24
TTS_REQUEST_TIMEOUT=30
TTS_MAX_RETRIES=3

# Azure TTS (fallback provider)
AZURE_TTS_KEY=xxx
AZURE_TTS_REGION=turkeycentral   # For KVKK compliance
```

### Coding Standards
[Source: architecture/coding-standards.md]

- Use `async/await` consistently for all provider operations
- Type hints required on all functions
- Use Pydantic for data validation
- Follow snake_case for variables/functions, PascalCase for classes
- Docstrings using Google style
- Error handling with specific exception types

---

## Testing

### Test File Location
`backend/app/tests/test_services/test_tts/`

### Test Standards
[Source: architecture/coding-standards.md]

- Use `pytest` with `pytest-asyncio`
- Mock external dependencies (no real TTS API calls in unit tests)
- Use `unittest.mock` or `pytest-mock`
- Follow arrange-act-assert pattern
- Aim for >80% coverage on new code

### Test Cases Summary

**test_base.py:**
- Test enum values and string representation
- Test Pydantic model validation and defaults
- Test model serialization

**test_exceptions.py:**
- Test exception inheritance
- Test exception message formatting
- Test AllTTSProvidersFailedError aggregation

**test_config.py:**
- Test default settings
- Test environment variable override
- Test provider type resolution methods

**test_cache.py:**
- Test cache operations (get, set, delete, clear)
- Test TTL expiration
- Test cache key generation consistency
- Test thread safety (basic)

**test_manager.py:**
- Test provider registration
- Test available providers list
- Test generate_audio routing
- Test fallback on primary failure
- Test cache integration (hit and miss)
- Test all providers failed scenario
- Test batch generation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-02 | 0.1 | Initial story draft | Bob (SM Agent) |
| 2026-01-02 | 1.0 | Implementation complete - all 8 tasks done | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
- All 112 unit tests passing (`uv run pytest backend/app/tests/test_services/test_tts/ -v`)
- Ruff linting passes (`uv run ruff check backend/app/services/tts/`)
- Fixed cache key consistency issue in manager.py (voice_for_cache variable used consistently for both cache lookup and storage)

### Completion Notes List
- Implemented TTS provider abstraction layer following LLM provider patterns
- Created exception hierarchy with 8 specific exception types for error handling
- Created TTSProvider ABC with async generate_audio and generate_audio_batch methods
- Implemented AudioCache with in-memory storage, TTL support, and thread-safe operations
- TTSManager implements automatic fallback between primary and fallback providers
- Cache integration checks cache before provider call and stores results after generation
- All models use Pydantic for validation with proper defaults
- Google-style docstrings on all public methods
- Test coverage includes edge cases, TTL expiration, thread safety, and fallback scenarios

### File List
**New Source Files:**
- `backend/app/services/tts/__init__.py` - Module exports
- `backend/app/services/tts/base.py` - TTSProvider ABC, enums, Pydantic models
- `backend/app/services/tts/cache.py` - AudioCache with TTL support
- `backend/app/services/tts/config.py` - TTSSettings configuration
- `backend/app/services/tts/exceptions.py` - TTS exception hierarchy
- `backend/app/services/tts/manager.py` - TTSManager with fallback
- `backend/app/services/tts/providers/__init__.py` - Provider package (placeholder)

**New Test Files:**
- `backend/app/tests/test_services/test_tts/__init__.py`
- `backend/app/tests/test_services/test_tts/test_base.py` - 19 tests
- `backend/app/tests/test_services/test_tts/test_cache.py` - 25 tests
- `backend/app/tests/test_services/test_tts/test_config.py` - 16 tests
- `backend/app/tests/test_services/test_tts/test_exceptions.py` - 17 tests
- `backend/app/tests/test_services/test_tts/test_manager.py` - 35 tests

---

## QA Results
_To be filled by QA agent_
