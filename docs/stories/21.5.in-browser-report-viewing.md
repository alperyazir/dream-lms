# Story 21.5: In-Browser Report Viewing

**Epic:** 21 - Teacher Resources & Materials Fixes
**Story ID:** 21.5
**Status:** Done
**Created:** 2025-12-20
**Priority:** Medium

---

## Story

**As a** Teacher generating student reports,
**I want** to view reports in the browser before downloading,
**so that** I can review content and decide if I need to make changes or download.

---

## Acceptance Criteria

### Report Display
1. After generating a report, it displays in the browser
2. PDF is viewable and scrollable
3. Report shows immediately after generation (no page reload)
4. Loading state while report generates

### Viewer Features
5. Download button available
6. Print button available
7. Zoom controls (optional)
8. Page navigation for multi-page reports (optional)

### User Experience
9. Viewer doesn't require additional plugins
10. Fallback for browsers that can't display PDFs
11. Close/dismiss viewer option
12. Can generate new report without closing viewer

### Accessibility
13. Keyboard navigation support
14. Screen reader compatible (for controls)

---

## Tasks / Subtasks

### Task 1: Create PDF Viewer Component (AC: 1-8)

- [ ] Create report viewer component:

```typescript
// frontend/src/components/reports/ReportViewer.tsx

import { useState } from 'react'
import { Download, Printer, X, ZoomIn, ZoomOut } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Slider } from '@/components/ui/slider'

interface ReportViewerProps {
  reportUrl: string
  filename: string
  onClose?: () => void
  className?: string
}

export function ReportViewer({
  reportUrl,
  filename,
  onClose,
  className,
}: ReportViewerProps) {
  const [zoom, setZoom] = useState(100)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const handleDownload = () => {
    const link = document.createElement('a')
    link.href = reportUrl
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }

  const handlePrint = () => {
    // Open PDF in new window for printing
    const printWindow = window.open(reportUrl, '_blank')
    if (printWindow) {
      printWindow.onload = () => {
        printWindow.print()
      }
    }
  }

  return (
    <div className={cn('flex flex-col bg-background border rounded-lg', className)}>
      {/* Toolbar */}
      <div className="flex items-center justify-between p-3 border-b bg-muted/50">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium truncate max-w-xs">
            {filename}
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Zoom Controls */}
          <div className="hidden md:flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setZoom(Math.max(50, zoom - 25))}
              disabled={zoom <= 50}
            >
              <ZoomOut className="h-4 w-4" />
            </Button>
            <span className="text-sm w-12 text-center">{zoom}%</span>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setZoom(Math.min(200, zoom + 25))}
              disabled={zoom >= 200}
            >
              <ZoomIn className="h-4 w-4" />
            </Button>
          </div>

          <div className="h-6 w-px bg-border mx-2 hidden md:block" />

          {/* Actions */}
          <Button variant="outline" size="sm" onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            Print
          </Button>

          <Button variant="outline" size="sm" onClick={handleDownload}>
            <Download className="h-4 w-4 mr-2" />
            Download
          </Button>

          {onClose && (
            <Button variant="ghost" size="icon" onClick={onClose}>
              <X className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>

      {/* PDF Content */}
      <div className="relative flex-1 min-h-0 bg-muted/20">
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center">
              <Loader2 className="h-8 w-8 animate-spin mx-auto mb-2" />
              <p className="text-sm text-muted-foreground">Loading report...</p>
            </div>
          </div>
        )}

        {error ? (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center">
              <AlertCircle className="h-8 w-8 text-destructive mx-auto mb-2" />
              <p className="text-sm text-destructive mb-4">{error}</p>
              <Button variant="outline" onClick={handleDownload}>
                Download Instead
              </Button>
            </div>
          </div>
        ) : (
          <iframe
            src={`${reportUrl}#toolbar=0&zoom=${zoom}`}
            className="w-full h-full border-0"
            style={{ minHeight: '600px' }}
            title="Report Preview"
            onLoad={() => setIsLoading(false)}
            onError={() => {
              setIsLoading(false)
              setError('Unable to display PDF. Try downloading instead.')
            }}
          />
        )}
      </div>
    </div>
  )
}
```

### Task 2: Create Report Generation Flow (AC: 1, 3-4)

- [ ] Update report generation to show viewer:

```typescript
// frontend/src/components/reports/GenerateReportButton.tsx

interface GenerateReportButtonProps {
  studentId: string
  assignmentId?: string
  type?: 'progress' | 'assignment' | 'full'
}

export function GenerateReportButton({
  studentId,
  assignmentId,
  type = 'progress',
}: GenerateReportButtonProps) {
  const [reportUrl, setReportUrl] = useState<string | null>(null)
  const [reportFilename, setReportFilename] = useState<string>('')
  const [showViewer, setShowViewer] = useState(false)

  const generateMutation = useMutation({
    mutationFn: async () => {
      const response = await reportsApi.generateReport({
        studentId,
        assignmentId,
        type,
      })
      return response
    },
    onSuccess: (data) => {
      setReportUrl(data.url)
      setReportFilename(data.filename)
      setShowViewer(true)
    },
    onError: () => {
      toast.error('Failed to generate report')
    },
  })

  return (
    <>
      <Button
        onClick={() => generateMutation.mutate()}
        disabled={generateMutation.isPending}
      >
        {generateMutation.isPending ? (
          <>
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            Generating...
          </>
        ) : (
          <>
            <FileText className="h-4 w-4 mr-2" />
            Generate Report
          </>
        )}
      </Button>

      {/* Report Viewer Dialog */}
      <Dialog open={showViewer} onOpenChange={setShowViewer}>
        <DialogContent className="max-w-5xl h-[90vh]">
          <DialogHeader>
            <DialogTitle>Report Preview</DialogTitle>
          </DialogHeader>
          {reportUrl && (
            <ReportViewer
              reportUrl={reportUrl}
              filename={reportFilename}
              className="flex-1"
            />
          )}
        </DialogContent>
      </Dialog>
    </>
  )
}
```

### Task 3: Alternative - Inline Viewer (AC: 1-4, 11-12)

- [ ] For inline viewing without dialog:

```typescript
// frontend/src/components/reports/InlineReportViewer.tsx

interface InlineReportViewerProps {
  studentId: string
  assignmentId?: string
}

export function InlineReportViewer({
  studentId,
  assignmentId,
}: InlineReportViewerProps) {
  const [reportData, setReportData] = useState<{
    url: string
    filename: string
  } | null>(null)

  const generateMutation = useMutation({
    mutationFn: () => reportsApi.generateReport({ studentId, assignmentId }),
    onSuccess: (data) => {
      setReportData(data)
    },
  })

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-4">
        <Button
          onClick={() => generateMutation.mutate()}
          disabled={generateMutation.isPending}
        >
          {generateMutation.isPending ? 'Generating...' : 'Generate Report'}
        </Button>

        {reportData && (
          <Button
            variant="outline"
            onClick={() => setReportData(null)}
          >
            Clear
          </Button>
        )}
      </div>

      {reportData && (
        <Card>
          <ReportViewer
            reportUrl={reportData.url}
            filename={reportData.filename}
            className="h-[600px]"
          />
        </Card>
      )}
    </div>
  )
}
```

### Task 4: Backend - Return Report URL (AC: 1, 3)

- [ ] Update report generation endpoint:

```python
# backend/app/api/routes/reports.py

class ReportResponse(BaseModel):
    url: str
    filename: str
    expires_at: datetime

@router.post("/students/{student_id}/report")
async def generate_student_report(
    student_id: uuid.UUID,
    assignment_id: uuid.UUID | None = None,
    report_type: str = "progress",
    session: SessionDep,
    current_user: User = require_role(UserRole.teacher),
):
    """Generate a student report and return URL for viewing."""
    student = session.get(User, student_id)
    if not student:
        raise HTTPException(404, "Student not found")

    assignment = None
    if assignment_id:
        assignment = session.get(Assignment, assignment_id)

    # Generate report
    pdf_content = await generate_report_pdf(student, assignment, report_type)

    # Generate filename
    filename = generate_report_filename(student, assignment)

    # Store temporarily (or in DCS with expiring access)
    report_id = str(uuid.uuid4())
    report_path = f"temp/reports/{report_id}.pdf"

    # Option 1: Store in DCS with signed URL
    dcs_client = get_dcs_client()
    await dcs_client.upload_bytes(pdf_content, report_path)
    url = dcs_client.get_signed_url(report_path, expires_in=3600)

    # Option 2: Store locally and serve via API
    # save_temp_report(report_id, pdf_content)
    # url = f"/api/v1/reports/view/{report_id}"

    return ReportResponse(
        url=url,
        filename=filename,
        expires_at=datetime.now(UTC) + timedelta(hours=1),
    )


@router.get("/view/{report_id}")
async def view_report(
    report_id: str,
    session: SessionDep,
    current_user: User = Depends(get_current_user),
):
    """Serve a generated report for viewing."""
    # Verify report exists and user has access
    report_content = get_temp_report(report_id)
    if not report_content:
        raise HTTPException(404, "Report not found or expired")

    return Response(
        content=report_content,
        media_type="application/pdf",
        headers={
            "Content-Disposition": "inline",  # 'inline' for viewing, 'attachment' for download
        }
    )
```

### Task 5: Handle Browser Compatibility (AC: 9-10)

- [ ] Add fallback for browsers without PDF support:

```typescript
// frontend/src/components/reports/ReportViewer.tsx

export function ReportViewer({ reportUrl, filename, onClose }: ReportViewerProps) {
  const [canDisplayPdf, setCanDisplayPdf] = useState(true)

  // Check PDF support
  useEffect(() => {
    // Some mobile browsers can't display PDFs
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent)
    const isAndroid = /Android/.test(navigator.userAgent)
    const isMobile = isIOS || isAndroid

    // Chrome/Firefox/Safari on desktop support PDF
    // But mobile browsers often don't
    if (isMobile) {
      setCanDisplayPdf(false)
    }
  }, [])

  if (!canDisplayPdf) {
    return (
      <div className={cn('flex flex-col items-center justify-center p-8', className)}>
        <FileText className="h-16 w-16 text-muted-foreground mb-4" />
        <h3 className="text-lg font-medium mb-2">Report Ready</h3>
        <p className="text-sm text-muted-foreground text-center mb-4">
          Your browser doesn't support inline PDF viewing.
          Please download the report to view it.
        </p>
        <div className="flex gap-2">
          <Button onClick={handleDownload}>
            <Download className="h-4 w-4 mr-2" />
            Download Report
          </Button>
          <Button variant="outline" onClick={handlePrint}>
            <Printer className="h-4 w-4 mr-2" />
            Print
          </Button>
        </div>
      </div>
    )
  }

  // Normal PDF viewer for supported browsers
  return (
    // ... existing viewer code
  )
}
```

### Task 6: Add Keyboard Navigation (AC: 13)

- [ ] Add keyboard support:

```typescript
// frontend/src/components/reports/ReportViewer.tsx

useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape' && onClose) {
      onClose()
    }
    if (e.key === 'p' && e.ctrlKey) {
      e.preventDefault()
      handlePrint()
    }
    if (e.key === 's' && e.ctrlKey) {
      e.preventDefault()
      handleDownload()
    }
  }

  window.addEventListener('keydown', handleKeyDown)
  return () => window.removeEventListener('keydown', handleKeyDown)
}, [onClose])
```

### Task 7: Alternative - Use React-PDF Library (AC: 5-8)

- [ ] For more control, use react-pdf:

```typescript
// frontend/src/components/reports/PDFViewer.tsx

import { Document, Page, pdfjs } from 'react-pdf'
import 'react-pdf/dist/esm/Page/AnnotationLayer.css'
import 'react-pdf/dist/esm/Page/TextLayer.css'

// Set worker
pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.js`

interface PDFViewerProps {
  url: string
  filename: string
}

export function PDFViewer({ url, filename }: PDFViewerProps) {
  const [numPages, setNumPages] = useState<number | null>(null)
  const [pageNumber, setPageNumber] = useState(1)
  const [scale, setScale] = useState(1.0)

  const onDocumentLoadSuccess = ({ numPages }: { numPages: number }) => {
    setNumPages(numPages)
  }

  return (
    <div className="flex flex-col h-full">
      {/* Controls */}
      <div className="flex items-center justify-between p-2 border-b">
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setPageNumber(Math.max(1, pageNumber - 1))}
            disabled={pageNumber <= 1}
          >
            Previous
          </Button>
          <span className="text-sm">
            Page {pageNumber} of {numPages || '?'}
          </span>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setPageNumber(Math.min(numPages || 1, pageNumber + 1))}
            disabled={pageNumber >= (numPages || 1)}
          >
            Next
          </Button>
        </div>

        <div className="flex items-center gap-2">
          <Button variant="ghost" size="sm" onClick={() => setScale(s => Math.max(0.5, s - 0.25))}>
            -
          </Button>
          <span className="text-sm w-16 text-center">{Math.round(scale * 100)}%</span>
          <Button variant="ghost" size="sm" onClick={() => setScale(s => Math.min(2, s + 0.25))}>
            +
          </Button>
        </div>
      </div>

      {/* PDF Content */}
      <div className="flex-1 overflow-auto p-4 bg-muted/20">
        <Document
          file={url}
          onLoadSuccess={onDocumentLoadSuccess}
          loading={<LoadingSpinner />}
          error={<ErrorMessage />}
        >
          <Page
            pageNumber={pageNumber}
            scale={scale}
            renderTextLayer={true}
            renderAnnotationLayer={true}
          />
        </Document>
      </div>
    </div>
  )
}
```

### Task 8: Write Tests (AC: 1-14)

- [ ] Test report viewer:

```typescript
describe('ReportViewer', () => {
  it('displays PDF in iframe', () => {
    render(<ReportViewer reportUrl="/test.pdf" filename="report.pdf" />)

    const iframe = screen.getByTitle('Report Preview')
    expect(iframe).toBeInTheDocument()
    expect(iframe).toHaveAttribute('src', expect.stringContaining('/test.pdf'))
  })

  it('shows download button', () => {
    render(<ReportViewer reportUrl="/test.pdf" filename="report.pdf" />)
    expect(screen.getByText('Download')).toBeInTheDocument()
  })

  it('shows print button', () => {
    render(<ReportViewer reportUrl="/test.pdf" filename="report.pdf" />)
    expect(screen.getByText('Print')).toBeInTheDocument()
  })

  it('shows fallback on mobile', () => {
    // Mock mobile user agent
    vi.spyOn(navigator, 'userAgent', 'get').mockReturnValue('iPhone')

    render(<ReportViewer reportUrl="/test.pdf" filename="report.pdf" />)

    expect(screen.getByText(/doesn't support inline PDF/)).toBeInTheDocument()
  })

  it('handles close callback', () => {
    const onClose = vi.fn()
    render(<ReportViewer reportUrl="/test.pdf" filename="report.pdf" onClose={onClose} />)

    fireEvent.click(screen.getByLabelText('Close'))
    expect(onClose).toHaveBeenCalled()
  })
})

describe('GenerateReportButton', () => {
  it('shows viewer after generation', async () => {
    vi.spyOn(reportsApi, 'generateReport').mockResolvedValue({
      url: '/generated.pdf',
      filename: 'student_report.pdf',
    })

    render(<GenerateReportButton studentId="123" />)

    fireEvent.click(screen.getByText('Generate Report'))

    await waitFor(() => {
      expect(screen.getByTitle('Report Preview')).toBeInTheDocument()
    })
  })
})
```

---

## Technical Notes

### Files to Create

| File | Description |
|------|-------------|
| `frontend/src/components/reports/ReportViewer.tsx` | PDF viewer component |
| `frontend/src/components/reports/GenerateReportButton.tsx` | Generation + view button |

### Files to Modify

| File | Changes |
|------|---------|
| `backend/app/api/routes/reports.py` | Return URL instead of direct download |
| `frontend/src/services/reportsApi.ts` | Update to get URL response |

### PDF Viewing Options

| Option | Pros | Cons |
|--------|------|------|
| iframe | Simple, native | Limited control, browser-dependent |
| react-pdf | Full control, page navigation | Larger bundle, setup complexity |
| PDF.js directly | Maximum control | Most complex to implement |
| Object embed | Native | Less compatible |

**Recommendation**: Start with iframe, add react-pdf if more features needed.

### Report URL Strategy

1. **Signed URLs**: DCS generates temporary signed URL
   - Pros: Secure, scalable
   - Cons: URL expires, needs DCS support

2. **API Endpoint**: Serve via backend
   - Pros: Full control, authentication built-in
   - Cons: Backend load, streaming needed

---

## Dependencies

- Report generation service (existing)
- DCS for report storage

---

## Estimation

- **Complexity:** Medium
- **Components:** 2 new components

---

## Definition of Done

- [ ] Generated report displays in browser
- [ ] PDF is viewable and scrollable
- [ ] Download button works
- [ ] Print button works
- [ ] Fallback for unsupported browsers
- [ ] Report shows immediately after generation
- [ ] Tests pass

---

## Test Scenarios

| Scenario | Expected Result |
|----------|-----------------|
| Generate report | Report displays in viewer |
| Click Download | PDF downloads with correct filename |
| Click Print | Browser print dialog opens |
| View on mobile | Fallback with download option shown |
| Close viewer | Viewer closes, can generate again |

---

## Dev Agent Record

### Agent Model Used
- [ ] Record model info on story start

### Tasks
_Checkboxes updated during implementation_

### Debug Log References
_Add links to debug log entries if issues arise_

### Completion Notes
_Notes added upon story completion_

### Change Log
| Date | Change | Author |
|------|--------|--------|
| 2025-12-20 | Story created | John (PM) |
