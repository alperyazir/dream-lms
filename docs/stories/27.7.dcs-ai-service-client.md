# Story 27.7: DCS AI Service Client

**Status:** Ready for Review

**Epic:** Epic 27 - DreamAI - AI-Powered Content Generation
**Story Points:** 5
**Priority:** High
**Dependencies:** Stories 27.1-27.6 (LLM/TTS Provider Layers)

---

## Story

**As a** system,
**I want** a dedicated service layer to consume DCS AI-data endpoints,
**so that** the LMS can fetch pre-processed book modules, vocabulary, and audio for AI content generation.

---

## Acceptance Criteria

1. [ ] HTTP client for DCS `/books/{book_id}/ai-data/*` endpoints
2. [ ] Authentication using LMS API key or JWT (reuse existing DCS authentication)
3. [ ] Fetch processing metadata and status
4. [ ] Fetch module list and details (text, topics, vocabulary_ids)
5. [ ] Fetch vocabulary with audio paths
6. [ ] Resolve presigned audio URLs
7. [ ] Handle 404 for unprocessed books gracefully
8. [ ] Cache responses with appropriate TTL:
   - Metadata: 1 minute (may change during processing)
   - Modules: 5 minutes (relatively static)
   - Vocabulary: 5 minutes
   - Audio URLs: 1 hour (presigned URLs valid for 1 hour)

---

## Tasks / Subtasks

- [x] **Task 1: Create DCS AI Data Models** (AC: 3, 4, 5)
  - [x] Create `backend/app/schemas/dcs_ai_data.py`
  - [x] Define `ProcessingMetadata` Pydantic model with fields:
    - `book_id: str`
    - `processing_status: str` (pending, processing, completed, partial, failed)
    - `total_pages: int`
    - `total_modules: int`
    - `total_vocabulary: int`
    - `total_audio_files: int`
    - `languages: list[str]`
    - `primary_language: str`
    - `difficulty_range: list[str]` (CEFR levels)
    - `stages: dict | None`
  - [x] Define `ModuleSummary` Pydantic model with fields:
    - `module_id: int`
    - `title: str`
    - `pages: list[int]`
    - `word_count: int`
  - [x] Define `ModuleListResponse` Pydantic model with fields:
    - `book_id: str`
    - `total_modules: int`
    - `modules: list[ModuleSummary]`
  - [x] Define `ModuleDetail` Pydantic model with fields:
    - `module_id: int`
    - `title: str`
    - `pages: list[int]`
    - `text: str`
    - `topics: list[str]`
    - `vocabulary_ids: list[str]`
    - `language: str`
    - `difficulty: str`
  - [x] Define `VocabularyWord` Pydantic model with fields:
    - `id: str`
    - `word: str`
    - `translation: str | None`
    - `definition: str`
    - `part_of_speech: str`
    - `level: str` (CEFR)
    - `example: str | None`
    - `module_id: int`
    - `module_title: str | None`
    - `page: int | None`
    - `audio: dict[str, str] | None` (word/translation audio paths)
  - [x] Define `VocabularyResponse` Pydantic model with fields:
    - `book_id: str`
    - `language: str`
    - `translation_language: str | None`
    - `total_words: int`
    - `words: list[VocabularyWord]`
    - `extracted_at: str | None`
  - [x] Add Google-style docstrings to all models

- [x] **Task 2: Create DCS AI Exception Classes** (AC: 7)
  - [x] Create `backend/app/services/dcs_ai/exceptions.py`
  - [x] Define `DCSAIDataError` base exception
  - [x] Define `DCSAIDataNotFoundError` for 404 (unprocessed books)
  - [x] Define `DCSAIDataNotReadyError` for processing/pending status
  - [x] Define `DCSAIDataAuthError` for authentication failures
  - [x] Define `DCSAIDataConnectionError` for network issues
  - [x] Add docstrings explaining when each exception is raised

- [x] **Task 3: Create DCS AI Cache Keys** (AC: 8)
  - [x] Update `backend/app/services/dcs_cache.py` OR create `backend/app/services/dcs_ai/cache.py`
  - [x] Add cache key patterns for AI data:
    - `AI_METADATA = "dcs:ai:metadata:{book_id}"` (TTL: 60s)
    - `AI_MODULES = "dcs:ai:modules:{book_id}"` (TTL: 300s)
    - `AI_MODULE_DETAIL = "dcs:ai:module:{book_id}:{module_id}"` (TTL: 300s)
    - `AI_VOCABULARY = "dcs:ai:vocabulary:{book_id}"` (TTL: 300s)
    - `AI_VOCABULARY_MODULE = "dcs:ai:vocabulary:{book_id}:{module_id}"` (TTL: 300s)
    - `AI_AUDIO_URL = "dcs:ai:audio:{book_id}:{lang}:{word}"` (TTL: 3600s)
  - [x] Add helper methods for generating cache keys with parameters

- [x] **Task 4: Create DCS AI Service Client** (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [x] Create `backend/app/services/dcs_ai/__init__.py`
  - [x] Create `backend/app/services/dcs_ai/client.py`
  - [x] Implement `DCSAIServiceClient` class:
    - Constructor accepts `DreamCentralStorageClient` and `DCSCache`
    - Reuse existing DCS authentication (JWT from `DreamCentralStorageClient`)
  - [x] Implement `async get_processing_status(book_id: int) -> ProcessingMetadata | None`:
    - Endpoint: `GET /books/{book_id}/ai-data/metadata`
    - Cache: 1 minute TTL
    - Return `None` on 404 (book not processed)
  - [x] Implement `async get_modules(book_id: int) -> ModuleListResponse | None`:
    - Endpoint: `GET /books/{book_id}/ai-data/modules`
    - Cache: 5 minutes TTL
    - Return `None` on 404
  - [x] Implement `async get_module_detail(book_id: int, module_id: int) -> ModuleDetail | None`:
    - Endpoint: `GET /books/{book_id}/ai-data/modules/{module_id}`
    - Cache: 5 minutes TTL
    - Return `None` on 404
  - [x] Implement `async get_vocabulary(book_id: int, module_id: int | None = None) -> VocabularyResponse | None`:
    - Endpoint: `GET /books/{book_id}/ai-data/vocabulary?module={id}`
    - Cache: 5 minutes TTL
    - Return `None` on 404
  - [x] Implement `async get_audio_url(book_id: int, lang: str, word: str) -> str | None`:
    - Endpoint: `GET /books/{book_id}/ai-data/audio/vocabulary/{lang}/{word}.mp3`
    - Returns presigned URL
    - Cache: 1 hour TTL (presigned URLs valid for 1 hour)
    - Return `None` on 404
  - [x] Implement `async is_book_processed(book_id: int) -> bool`:
    - Helper to check if book has AI data available
    - Uses `get_processing_status` and checks `processing_status == "completed"`

- [x] **Task 5: Add Error Handling and Retry Logic** (AC: 7)
  - [x] Wrap DCS client calls with exception handling
  - [x] Map DCS errors to DCS AI exceptions:
    - `DreamStorageNotFoundError` -> `DCSAIDataNotFoundError`
    - `DreamStorageAuthError` -> `DCSAIDataAuthError`
    - `DreamStorageServerError` -> `DCSAIDataConnectionError`
  - [x] Log errors with context (book_id, module_id, etc.)
  - [x] Return `None` instead of raising for 404s (graceful degradation)

- [x] **Task 6: Add Logging** (AC: All)
  - [x] Add structured logging for all API calls
  - [x] Log cache hits/misses with book_id context
  - [x] Log processing status checks
  - [x] Log audio URL resolutions

- [x] **Task 7: Create Factory Function and Dependency** (AC: 1)
  - [x] Implement `create_dcs_ai_client() -> DCSAIServiceClient`
  - [x] Add FastAPI dependency `get_dcs_ai_client`
  - [x] Export from `backend/app/services/dcs_ai/__init__.py`:
    - `DCSAIServiceClient`
    - `get_dcs_ai_client`
    - All exception classes
    - All schema models

- [x] **Task 8: Write Unit Tests** (AC: All)
  - [x] Create `backend/app/tests/test_services/test_dcs_ai/` directory
  - [x] Create `backend/app/tests/test_services/test_dcs_ai/__init__.py`
  - [x] Create `backend/app/tests/test_services/test_dcs_ai/test_client.py`
  - [x] Test `get_processing_status` with mocked DCS client:
    - Returns metadata for processed book
    - Returns None for 404
    - Uses cache on second call
    - Cache expires after TTL
  - [x] Test `get_modules` with mocked DCS client:
    - Returns module list
    - Returns None for unprocessed book
    - Caches response
  - [x] Test `get_module_detail` with mocked DCS client
  - [x] Test `get_vocabulary` with and without module filter
  - [x] Test `get_audio_url` returns presigned URL
  - [x] Test `is_book_processed` helper
  - [x] Test exception mapping (DCS errors -> DCS AI errors)
  - [x] Test cache invalidation works correctly
  - [x] Create `backend/app/tests/test_services/test_dcs_ai/test_schemas.py`
  - [x] Test all Pydantic model validation
  - [x] Test optional fields and defaults

---

## Dev Notes

### Previous Story Insights
[Source: docs/stories/27.1-27.6]

**From Stories 27.1-27.6 (LLM/TTS Provider Layers):**
- Service modules organized under `backend/app/services/<domain>/`
- Each domain has: `__init__.py`, `base.py`, `config.py`, `exceptions.py`, `manager.py`, `providers/`
- Exception hierarchies follow pattern: Base -> Specific (e.g., `TTSError` -> `TTSConnectionError`)
- Google-style docstrings required on all public methods
- Settings injected via Pydantic `BaseSettings`

### DCS Client Pattern (CRITICAL)
[Source: backend/app/services/dream_storage_client.py]

The existing `DreamCentralStorageClient` provides:
- JWT authentication with automatic token refresh
- Retry logic with exponential backoff (3 retries)
- Connection pooling (max 10 concurrent)
- Built-in caching for responses
- Exception classes: `DreamStorageNotFoundError`, `DreamStorageAuthError`, `DreamStorageServerError`

**REUSE THIS CLIENT** - Do not create a new HTTP client. Extend or compose with the existing client.

```python
# Pattern to follow:
class DCSAIServiceClient:
    def __init__(
        self,
        dcs_client: DreamCentralStorageClient,
        cache: DCSCache
    ):
        self._dcs = dcs_client
        self._cache = cache

    async def get_processing_status(self, book_id: int) -> ProcessingMetadata | None:
        cache_key = f"dcs:ai:metadata:{book_id}"
        cached = await self._cache.get(cache_key)
        if cached:
            return cached

        try:
            # Uses existing DCS client auth
            response = await self._dcs._make_request(
                "GET", f"/books/{book_id}/ai-data/metadata"
            )
            data = ProcessingMetadata(**response.json())
            await self._cache.set(cache_key, data, ttl=60)
            return data
        except DreamStorageNotFoundError:
            return None
```

### DCS Cache Pattern
[Source: backend/app/services/dcs_cache.py]

Use existing `DCSCache` class with `get_or_fetch` pattern:

```python
async def get_or_fetch(
    self,
    key: str,
    fetch_fn: Callable[[], Awaitable[T]],
    ttl: int | None = None,
) -> T
```

Add new cache key patterns to `CacheKeys` class:

```python
# AI Data keys
AI_METADATA = "dcs:ai:metadata:{book_id}"
AI_MODULES = "dcs:ai:modules:{book_id}"
AI_MODULE_DETAIL = "dcs:ai:module:{book_id}:{module_id}"
AI_VOCABULARY = "dcs:ai:vocabulary:{book_id}"
AI_VOCABULARY_MODULE = "dcs:ai:vocabulary:{book_id}:{module_id}"
AI_AUDIO_URL = "dcs:ai:audio:{book_id}:{lang}:{word}"

@staticmethod
def ai_metadata(book_id: int) -> str:
    return CacheKeys.AI_METADATA.format(book_id=book_id)
```

### DCS AI-Data Endpoints (From Epic)
[Source: docs/prd/epic-27-dreamai-content-generation.md]

| Method | DCS Endpoint | Description |
|--------|--------------|-------------|
| GET | `/books/{book_id}/ai-data/metadata` | Processing metadata, status, totals |
| GET | `/books/{book_id}/ai-data/modules` | List all modules (module_id, title, pages, word_count) |
| GET | `/books/{book_id}/ai-data/modules/{module_id}` | Full module (text, topics, vocabulary_ids, language, difficulty) |
| GET | `/books/{book_id}/ai-data/vocabulary?module={id}` | Vocabulary words with audio paths |
| GET | `/books/{book_id}/ai-data/audio/vocabulary/{lang}/{word}.mp3` | Presigned audio URL |

### Data Models (From Epic)
[Source: docs/prd/epic-27-dreamai-content-generation.md]

**ProcessingMetadata:**
```json
{
  "book_id": "123",
  "processing_status": "completed",  // pending, processing, completed, partial, failed
  "total_pages": 120,
  "total_modules": 12,
  "total_vocabulary": 450,
  "total_audio_files": 900,
  "languages": ["en", "tr"],
  "primary_language": "en",
  "difficulty_range": ["A1", "A2", "B1"],
  "stages": { ... }
}
```

**VocabularyWord:**
```json
{
  "id": "vocab_123",
  "word": "accomplish",
  "translation": "baarmak",
  "definition": "to succeed in doing something",
  "part_of_speech": "verb",
  "level": "B1",
  "example": "She accomplished her goal.",
  "module_id": 3,
  "module_title": "Unit 3: Achievements",
  "page": 45,
  "audio": {
    "word": "audio/vocabulary/en/accomplish.mp3",
    "translation": "audio/vocabulary/tr/accomplish.mp3"
  }
}
```

### Cache TTL Requirements
[Source: docs/prd/epic-27-dreamai-content-generation.md]

| Data Type | TTL | Reason |
|-----------|-----|--------|
| Metadata | 60 seconds | May change during processing |
| Modules | 300 seconds | Relatively static |
| Vocabulary | 300 seconds | Relatively static |
| Audio URLs | 3600 seconds | Presigned URLs valid for 1 hour |

### Source Tree Reference
[Source: docs/architecture/source-tree.md]

New files to create:
```
backend/app/services/dcs_ai/
├── __init__.py          # Exports: DCSAIServiceClient, get_dcs_ai_client, exceptions
├── client.py            # DCSAIServiceClient implementation
└── exceptions.py        # DCS AI specific exceptions

backend/app/schemas/
└── dcs_ai_data.py       # Pydantic models for AI data responses

backend/app/tests/test_services/test_dcs_ai/
├── __init__.py
├── test_client.py       # Client tests with mocked DCS
└── test_schemas.py      # Schema validation tests
```

Files to modify:
```
backend/app/services/dcs_cache.py   # Add AI-specific cache keys
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

- Use `async/await` for all network calls
- Type hints required on all functions
- Google-style docstrings on public methods
- Follow snake_case for variables/functions, PascalCase for classes
- Error handling with specific exception types
- Log all API calls with context

---

## Testing

### Test File Location
```
backend/app/tests/test_services/test_dcs_ai/test_client.py
backend/app/tests/test_services/test_dcs_ai/test_schemas.py
```

### Test Standards
[Source: docs/architecture/coding-standards.md, docs/architecture/10-testing-strategy.md]

- Use `pytest` with `pytest-asyncio`
- Mock external dependencies (`DreamCentralStorageClient`)
- Follow arrange-act-assert pattern
- Aim for >80% coverage on new code
- Test both success and error paths

### Mocking Strategy

```python
import pytest
from unittest.mock import AsyncMock, MagicMock

@pytest.fixture
def mock_dcs_client():
    """Mock DreamCentralStorageClient for testing."""
    client = MagicMock()
    client._make_request = AsyncMock()
    return client

@pytest.fixture
def mock_cache():
    """Mock DCSCache for testing."""
    cache = MagicMock()
    cache.get = AsyncMock(return_value=None)
    cache.set = AsyncMock()
    cache.get_or_fetch = AsyncMock()
    return cache

@pytest.fixture
def dcs_ai_client(mock_dcs_client, mock_cache):
    """Create DCSAIServiceClient with mocked dependencies."""
    from app.services.dcs_ai.client import DCSAIServiceClient
    return DCSAIServiceClient(dcs_client=mock_dcs_client, cache=mock_cache)
```

### Test Cases Summary

**test_client.py:**
- `test_get_processing_status_returns_metadata_for_processed_book`
- `test_get_processing_status_returns_none_for_404`
- `test_get_processing_status_uses_cache`
- `test_get_processing_status_cache_expires`
- `test_get_modules_returns_list`
- `test_get_modules_returns_none_for_unprocessed`
- `test_get_module_detail_returns_full_module`
- `test_get_vocabulary_without_filter`
- `test_get_vocabulary_with_module_filter`
- `test_get_audio_url_returns_presigned_url`
- `test_get_audio_url_caches_for_1_hour`
- `test_is_book_processed_returns_true_for_completed`
- `test_is_book_processed_returns_false_for_processing`
- `test_exception_mapping_not_found`
- `test_exception_mapping_auth_error`
- `test_exception_mapping_server_error`

**test_schemas.py:**
- `test_processing_metadata_valid`
- `test_processing_metadata_optional_fields`
- `test_module_summary_valid`
- `test_module_list_response_valid`
- `test_vocabulary_word_valid`
- `test_vocabulary_word_optional_audio`
- `test_vocabulary_response_valid`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-02 | 0.1 | Initial story draft | Bob (SM Agent) |
| 2026-01-02 | 1.0 | Implementation complete - all tasks done, 38 tests passing | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A - No debug issues encountered

### Completion Notes List
- All 8 tasks completed successfully
- 38 unit tests written and passing
- Linting passes (ruff)
- Client reuses existing DreamCentralStorageClient for authentication
- Cache keys added to existing CacheKeys class with appropriate TTLs
- Exception hierarchy created for proper error handling
- Factory function and FastAPI dependency created for dependency injection

### File List
**Created:**
- `backend/app/schemas/dcs_ai_data.py` - Pydantic models for AI data
- `backend/app/services/dcs_ai/__init__.py` - Module exports and factory
- `backend/app/services/dcs_ai/client.py` - Main DCSAIServiceClient
- `backend/app/services/dcs_ai/exceptions.py` - Exception classes
- `backend/app/tests/test_services/test_dcs_ai/__init__.py` - Test package
- `backend/app/tests/test_services/test_dcs_ai/test_client.py` - Client tests
- `backend/app/tests/test_services/test_dcs_ai/test_schemas.py` - Schema tests

**Modified:**
- `backend/app/services/dcs_cache.py` - Added AI cache keys and helpers

---

## QA Results
_To be filled by QA agent_
