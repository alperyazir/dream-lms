# Story 20.6: Preview Assignment Bug Fixes

**Epic:** 20 - Assignment Management Enhancements
**Story ID:** 20.6
**Status:** To Do
**Created:** 2025-12-20
**Priority:** High (Bug Fix)
**Note:** Status changed from "Ready for Review" to "To Do" - story requires implementation

---

## Story

**As a** Teacher previewing assignments,
**I want** the Show Answer and Reset buttons to work correctly,
**so that** I can test activities before assigning them to students.

---

## Acceptance Criteria

### Fix "Maximum Update Depth Exceeded" Error
1. Show Answer button does not cause infinite re-render loop
2. Error no longer appears when clicking Show Answer
3. Answer display works for all activity types
4. Console shows no React warnings

### Fix Reset Button
5. Reset button returns activity to initial state
6. All user input/selections cleared
7. Show Answer state reset (if answers were shown)
8. Activity ready for fresh attempt
9. Reset works for all activity types

### Error Handling
10. Error boundary catches unexpected errors gracefully
11. User sees friendly error message, not crash
12. Error is logged for debugging
13. User can retry or navigate away

### Activity Type Support
14. Fix works for all activity types:
    - Multiple Choice
    - Fill in the Blanks
    - Matching
    - Drag and Drop
    - True/False
    - Audio/Video activities
15. Preview mode consistent with student mode

---

## Tasks / Subtasks

### Task 1: Diagnose Maximum Update Depth Error (AC: 1-4)

- [ ] Identify the component causing infinite loop
- [ ] Common causes:
  - `useEffect` without proper dependencies
  - State update in render
  - Callback prop changing on every render

**Likely Issue Pattern:**

```typescript
// BAD: Creates new function on every render, triggers useEffect infinitely
const handleShowAnswer = () => {
  setShowAnswer(true)
  onAnswerShown?.(answers) // If this triggers parent re-render...
}

useEffect(() => {
  if (showAnswer) {
    calculateScore() // This might update state
  }
}, [showAnswer, calculateScore]) // calculateScore changes every render!

// GOOD: Stabilize callbacks and state updates
const calculateScore = useCallback(() => {
  // ...calculation
}, [answers]) // Only recalculate when answers change

useEffect(() => {
  if (showAnswer) {
    calculateScore()
  }
}, [showAnswer, calculateScore])
```

### Task 2: Fix Show Answer Functionality (AC: 1-4)

- [ ] Locate Show Answer handler in preview/test mode components
- [ ] Ensure state updates are batched and controlled
- [ ] Use `useCallback` for handlers to prevent recreation

```typescript
// frontend/src/components/activity-player/PreviewControls.tsx

interface PreviewControlsProps {
  onShowAnswer: () => void
  onReset: () => void
  showingAnswer: boolean
  isResetting: boolean
}

export function PreviewControls({
  onShowAnswer,
  onReset,
  showingAnswer,
  isResetting,
}: PreviewControlsProps) {
  return (
    <div className="flex items-center gap-2 p-4 bg-muted rounded-lg">
      <span className="text-sm font-medium text-muted-foreground mr-auto">
        Preview Mode
      </span>

      <Button
        variant="outline"
        size="sm"
        onClick={onShowAnswer}
        disabled={showingAnswer}
      >
        <Eye className="h-4 w-4 mr-2" />
        {showingAnswer ? 'Answers Shown' : 'Show Answer'}
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={onReset}
        disabled={isResetting}
      >
        <RotateCcw className="h-4 w-4 mr-2" />
        Reset
      </Button>
    </div>
  )
}
```

- [ ] Fix the state management in activity player:

```typescript
// frontend/src/components/activity-player/ActivityPlayer.tsx

export function ActivityPlayer({
  activity,
  mode, // 'preview' | 'student' | 'review'
  initialState,
}: ActivityPlayerProps) {
  const [state, setState] = useState<ActivityState>(() =>
    getInitialState(activity, initialState)
  )
  const [showAnswer, setShowAnswer] = useState(false)

  // Memoize callbacks to prevent infinite loops
  const handleShowAnswer = useCallback(() => {
    setShowAnswer(true)
    // Don't trigger any other state updates here!
  }, [])

  const handleReset = useCallback(() => {
    setState(getInitialState(activity))
    setShowAnswer(false)
  }, [activity])

  // Memoize derived values
  const correctAnswers = useMemo(() =>
    activity.correct_answers || [],
    [activity.correct_answers]
  )

  return (
    <div>
      {mode === 'preview' && (
        <PreviewControls
          onShowAnswer={handleShowAnswer}
          onReset={handleReset}
          showingAnswer={showAnswer}
          isResetting={false}
        />
      )}

      <ActivityContent
        activity={activity}
        state={state}
        onChange={setState}
        showAnswer={showAnswer}
        correctAnswers={correctAnswers}
        disabled={showAnswer}
      />
    </div>
  )
}
```

### Task 3: Fix Reset Functionality (AC: 5-9)

- [ ] Create proper initial state generator:

```typescript
// frontend/src/lib/activity-utils.ts

export function getInitialActivityState(activity: Activity): ActivityState {
  switch (activity.activity_type) {
    case 'multiple_choice':
      return {
        selectedOption: null,
        submitted: false,
      }

    case 'fill_blanks':
      return {
        blanks: activity.blanks.map(() => ''),
        submitted: false,
      }

    case 'matching':
      return {
        pairs: [],
        submitted: false,
      }

    case 'drag_drop':
      return {
        placements: {},
        submitted: false,
      }

    case 'true_false':
      return {
        selectedAnswer: null,
        submitted: false,
      }

    default:
      return {
        data: {},
        submitted: false,
      }
  }
}
```

- [ ] Implement reset in each activity component:

```typescript
// Example for MultipleChoiceActivity.tsx

interface MultipleChoiceState {
  selectedOption: string | null
  submitted: boolean
}

export function MultipleChoiceActivity({
  activity,
  state,
  onChange,
  showAnswer,
}: MultipleChoiceProps) {
  const handleSelect = useCallback((optionId: string) => {
    if (state.submitted || showAnswer) return
    onChange({ ...state, selectedOption: optionId })
  }, [state, showAnswer, onChange])

  return (
    <div className="space-y-3">
      {activity.options.map((option) => {
        const isSelected = state.selectedOption === option.id
        const isCorrect = showAnswer && option.is_correct
        const isWrong = showAnswer && isSelected && !option.is_correct

        return (
          <div
            key={option.id}
            className={cn(
              'p-4 border rounded-lg cursor-pointer transition-colors',
              isSelected && !showAnswer && 'border-primary bg-primary/5',
              isCorrect && 'border-green-500 bg-green-50',
              isWrong && 'border-red-500 bg-red-50',
              showAnswer && 'cursor-default'
            )}
            onClick={() => handleSelect(option.id)}
          >
            <div className="flex items-center gap-3">
              <div className={cn(
                'w-6 h-6 rounded-full border-2 flex items-center justify-center',
                isSelected && 'border-primary',
                isCorrect && 'border-green-500',
              )}>
                {isSelected && !showAnswer && <div className="w-3 h-3 rounded-full bg-primary" />}
                {isCorrect && <Check className="h-4 w-4 text-green-500" />}
                {isWrong && <X className="h-4 w-4 text-red-500" />}
              </div>
              <span>{option.text}</span>
            </div>
          </div>
        )
      })}
    </div>
  )
}
```

### Task 4: Add Error Boundary (AC: 10-13)

- [ ] Create error boundary for activity player:

```typescript
// frontend/src/components/activity-player/ActivityErrorBoundary.tsx

interface Props {
  children: React.ReactNode
  onError?: (error: Error) => void
  fallback?: React.ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ActivityErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Activity Player Error:', error, errorInfo)
    this.props.onError?.(error)

    // Log to monitoring service if available
    // logger.error('ActivityPlayer crash', { error, errorInfo })
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null })
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex flex-col items-center justify-center p-8 text-center">
          <AlertCircle className="h-12 w-12 text-destructive mb-4" />
          <h3 className="text-lg font-medium mb-2">Something went wrong</h3>
          <p className="text-sm text-muted-foreground mb-4">
            There was an error loading this activity.
          </p>
          <div className="flex gap-2">
            <Button variant="outline" onClick={this.handleRetry}>
              Try Again
            </Button>
            <Button variant="ghost" onClick={() => window.history.back()}>
              Go Back
            </Button>
          </div>
          {process.env.NODE_ENV === 'development' && (
            <pre className="mt-4 p-4 bg-muted rounded text-xs text-left max-w-md overflow-auto">
              {this.state.error?.message}
            </pre>
          )}
        </div>
      )
    }

    return this.props.children
  }
}

// Usage
export function PreviewActivityPage({ activityId }: { activityId: string }) {
  return (
    <ActivityErrorBoundary
      onError={(error) => console.error('Preview error:', error)}
    >
      <ActivityPlayer
        activityId={activityId}
        mode="preview"
      />
    </ActivityErrorBoundary>
  )
}
```

### Task 5: Test All Activity Types (AC: 14-15)

- [ ] Create test cases for each activity type:

```typescript
describe('ActivityPlayer Preview Mode', () => {
  const activityTypes = [
    'multiple_choice',
    'fill_blanks',
    'matching',
    'drag_drop',
    'true_false',
  ]

  activityTypes.forEach((type) => {
    describe(`${type} activity`, () => {
      const mockActivity = createMockActivity(type)

      it('renders without errors', () => {
        render(
          <ActivityPlayer
            activity={mockActivity}
            mode="preview"
          />
        )
        expect(screen.getByRole('article')).toBeInTheDocument()
      })

      it('Show Answer works without infinite loop', async () => {
        const { container } = render(
          <ActivityPlayer
            activity={mockActivity}
            mode="preview"
          />
        )

        const showAnswerBtn = screen.getByRole('button', { name: /show answer/i })
        fireEvent.click(showAnswerBtn)

        // Wait for any state updates
        await waitFor(() => {
          expect(screen.getByText(/answers shown/i)).toBeInTheDocument()
        })

        // Verify no console errors about update depth
        expect(console.error).not.toHaveBeenCalled()
      })

      it('Reset returns to initial state', async () => {
        render(
          <ActivityPlayer
            activity={mockActivity}
            mode="preview"
          />
        )

        // Make a selection
        const firstOption = screen.getByTestId('option-0')
        fireEvent.click(firstOption)

        // Click Reset
        const resetBtn = screen.getByRole('button', { name: /reset/i })
        fireEvent.click(resetBtn)

        // Verify selection cleared
        expect(firstOption).not.toHaveClass('selected')
      })

      it('catches errors gracefully', async () => {
        const brokenActivity = { ...mockActivity, options: null }

        render(
          <ActivityErrorBoundary>
            <ActivityPlayer
              activity={brokenActivity as any}
              mode="preview"
            />
          </ActivityErrorBoundary>
        )

        expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
      })
    })
  })
})
```

### Task 6: Add Developer Tools for Debugging

- [ ] Add debug panel in development mode:

```typescript
// frontend/src/components/activity-player/DebugPanel.tsx

export function ActivityDebugPanel({
  state,
  activity,
  showAnswer,
}: DebugPanelProps) {
  if (process.env.NODE_ENV !== 'development') return null

  return (
    <details className="mt-4 p-4 bg-muted rounded text-xs">
      <summary className="cursor-pointer font-medium">
        Debug Info (Dev Only)
      </summary>
      <div className="mt-2 space-y-2">
        <div>
          <strong>Activity Type:</strong> {activity.activity_type}
        </div>
        <div>
          <strong>Show Answer:</strong> {showAnswer ? 'Yes' : 'No'}
        </div>
        <div>
          <strong>State:</strong>
          <pre className="mt-1 overflow-auto">
            {JSON.stringify(state, null, 2)}
          </pre>
        </div>
        <div>
          <strong>Correct Answers:</strong>
          <pre className="mt-1 overflow-auto">
            {JSON.stringify(activity.correct_answers, null, 2)}
          </pre>
        </div>
      </div>
    </details>
  )
}
```

---

## Technical Notes

### Root Cause Analysis

The "Maximum update depth exceeded" error typically occurs when:

1. **State update in useEffect triggers re-render which triggers useEffect again**
2. **Unstable callback references passed as dependencies**
3. **Derived state that should be memoized**

Example of the problem pattern:
```typescript
// This creates an infinite loop!
const [score, setScore] = useState(0)

useEffect(() => {
  const newScore = calculateScore(answers)
  setScore(newScore)
}, [answers, calculateScore]) // calculateScore recreated each render

const calculateScore = (answers) => { ... } // NOT memoized!
```

### Files to Modify

| File | Changes |
|------|---------|
| `frontend/src/components/activity-player/ActivityPlayer.tsx` | Fix Show Answer, Reset |
| `frontend/src/components/activity-player/PreviewControls.tsx` | UI controls |
| `frontend/src/lib/activity-utils.ts` | Initial state helper |
| `frontend/src/components/activity-player/*.tsx` | Individual activity fixes |

### Files to Create

| File | Description |
|------|-------------|
| `frontend/src/components/activity-player/ActivityErrorBoundary.tsx` | Error boundary |
| `frontend/src/components/activity-player/DebugPanel.tsx` | Dev debugging |

### Checklist for Each Activity Type

| Activity Type | Show Answer | Reset | Error Boundary |
|--------------|-------------|-------|----------------|
| Multiple Choice | [ ] | [ ] | [ ] |
| Fill in Blanks | [ ] | [ ] | [ ] |
| Matching | [ ] | [ ] | [ ] |
| Drag and Drop | [ ] | [ ] | [ ] |
| True/False | [ ] | [ ] | [ ] |

---

## Dependencies

- Existing ActivityPlayer component
- Preview/Test mode routing

---

## Estimation

- **Complexity:** Medium-High (debugging required)
- **Risk:** Medium (core activity functionality)

---

## Definition of Done

- [ ] Show Answer works without console errors
- [ ] Reset clears all user input
- [ ] Error boundary catches crashes
- [ ] All activity types work in preview
- [ ] Tests pass for all activity types
- [ ] No "Maximum update depth" warnings

---

## Test Scenarios

| Scenario | Expected Result |
|----------|-----------------|
| Click Show Answer on Multiple Choice | Correct answer highlighted, no errors |
| Click Reset after making selection | Selection cleared, activity fresh |
| Preview broken activity data | Error message shown, can retry |
| Click Show Answer rapidly | No infinite loop, button becomes disabled |
| Reset after Show Answer | Both selection and answer display cleared |

---

## Dev Agent Record

### Agent Model Used
- [ ] Record model info on story start

### Tasks
_Checkboxes updated during implementation_

### Debug Log References
_Add links to debug log entries if issues arise_

### Completion Notes
_Notes added upon story completion_

### Change Log
| Date | Change | Author |
|------|--------|--------|
| 2025-12-20 | Story created | John (PM) |

---

## QA Results

### Review Date: 2025-12-26

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall:** **STORY NOT COMPLETED** - No implementation found.

**Status:** This story shows "Ready for Review" but has no completion notes, no checked tasks, no file list, and no implementation evidence.

**Critical Findings:**
- No Dev Agent Record completion notes
- No tasks marked as complete
- No file list provided
- No tests mentioned
- Definition of Done items all unchecked

### Compliance Check

- **Story Status:** ✗ INCORRECT - Marked "Ready for Review" but not implemented
- **All ACs Met:** ✗ NOT MET - No implementation exists

### Gate Status

**Gate:** FAIL → docs/qa/gates/20.6-preview-assignment-bug-fixes.yml

**Status Reason:** Story marked as ready for review but has no implementation. Status should be changed to "In Progress" or "To Do".

### Recommended Status

**✗ NOT READY FOR REVIEW** - Story needs to be implemented first.

**Required Actions:**
1. Change story status from "Ready for Review" to "To Do" or "In Progress"
2. Assign developer to implement the story
3. Fix the two bugs described in acceptance criteria:
   - AC 1-2: "Maximum update depth exceeded" error on Show Answer
   - AC 3-4: Reset button not working
4. Add error boundary (AC 5)
5. Create tests (AC 6-7)
6. Update file list when implementation complete
7. Re-submit for QA review after implementation

**Impact:** This story is blocking Epic 20 completion. The preview/test mode bugs affect teacher workflow quality.

